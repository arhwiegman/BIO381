---
title: "Homework 7"
author: "Adrian Wiegman"
date: "February 28, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# load packages
library(ggplot2);theme_set(theme_classic())
library(plyr)
library(multcompView)
# set working directory
setwd("C:/Users/Adria/Documents/R/Projects/BIO381/HW7")
# set random number seed
set.seed(100)
```
## Assigment Objectives

I am examinining the factors that influence flux of phosphorus (P) to and from inundated sediments. One indicator of P flux is the molar ratio of phosphorus to the aluminum plus iron yielded using a signle extractant, sometimes called the Degree of P Saturation, DPS. Depth is a major control on soil properties because correlates to gradients of oxgyen availability and organic matter. In this homework I reproduce data from Nair et al. 2004 who examine the relation between water soluble P (WSP)and the DPS in surface and subsurface soil horizons. I will generate random data based roughly on fig 1 below and perform a regression. I will test how many data points are needed to get a significant slope value, assuming that DPS is a random uniform number between 0 and 1 and WSP increases as function of DPS whose variance increases with DPS. 

![Fig. 1](FIg_Nair2004.png)

```{r}
# Define Functions------------------------------------

#########################################################################
#FUNCTION: simulateData
# function to simulate random normal data for a specified experimental setup
#inputs: 
# number of factors, blocks, treatments, replications in experiment
# sample mean and standard deviation of all samples
# the effect of factors, blocks, treatments, replications
#outputs:
#-------------------------------------------------------------------------
simulateLinearXY <- function(
                    n = 15, #number of samples
                    slope = 1,
                    intercept=0,
                    error=1
                    ){
  x = rnorm(n)
  y = intercept + slope*x + error*rnorm(n)
  df <- data.frame(y=y,x=x)
  
  return(df)
}
plot(simulateLinearXY()$x,simulateLinearXY()$y)
#######################################
#FUNCTION: simulateModel
#simulates y as a function of x
#input: x - a vector of x values
#       model - a string containing expression that tranforms x
#             example: for y = 5*x enter model = '5x'
#             check that the expression can be evaluated 
#             by replacing x with 1 and pasting in console (5*1)
#output: z - a list containng:
#             model - a string of the model equation
#             df - data frame of x and y values
#--------------------------------------
simulateModel <- function(
                    x = rnorm(15), #number of samples
                    model = '0 + 1*x + 1*rnorm(length(x))'
                    ){
  y <- eval(parse(text=model))
  df  <- data.frame(y=y,x=x)
  z <- list(model = paste('y = ',model), df = df)
  return(z)
} 
simulateModel()

###################################
#///FUNCTION: fitSLR
# fits simple linear regression for y as a function of x
#input: df - a dataframe of numeric values, first column = y 
#            df[,1] = y;  df[,2] = x
#outputs: a vectorized summary of lm results
#--------------------------------------
SLR_results <- function(df = NULL){
  if(is.null(df)) df<-data.frame(y=runif(15),x=runif(15))
  . <- lm(df[,1]~df[,2], data=df) # produces results as a list
  b0 <- .$coefficients[1] # vectorized regression outputs
  b1 <- .$coefficients[1] # summarized outputs
  p0 <- summary(.)$coefficients[1,4]
  p1 <- summary(.)$coefficients[2,4]
  r_sq <- summary(.)$r.squared
  . <- c(intercept=b0,slope=b1,p_intercept=p0,p_slope=p1,r_sq=r_sq)
  return(.)
}
SLR_results()
#######################################
#///FUNCTION: MLR_results
#conducts muliple regression and returns list of key results
#input: df - data frame of three or more numeric vectors
#       model - two sided formula object that uses the column 
#               names from the df
#output: a list of key results
#--------------------------------------
MLR_results <- function(df = NULL, model=NULL){
  if(is.null(df)) df<-data.frame(y=runif(15),x1=runif(15),x2=runif(15))
  if(is.null(model)) model <- as.formula('y~x1*x2')
  . <- lm(model, data=df) # produces results as a list
  betas <- .$coefficients # vectorized regression outputs
  betaPs <- summary(.)$coefficients[1:nrow(summary(.)$coefficients),4]
  fstats <- summary(.)$fstatistic
  r_sq <- summary(.)$r.squared
  rmse <- sqrt(mean(residuals(.)^2))
  aic <- AIC(.)
  . <- list(betas=betas,betaPs=betaPs,
            fstats=fstats,r_sq=r_sq,rmse=rmse,aic=aic)
}
MLR_results()

#########################################
#FUNCTION: plotSLR
#plot simple linear regression on xy scatter
#input: df - a two-column datafarme (y,x)
#       slope - slope value
#       intercept - intercept value
#output: plotted regression
plotSLR <- function(df=NULL){
  if(is.null(df)) df<-data.frame(y=runif(15),x=runif(15))
  .<-lm(y~x,data=df)
  eqn <- paste0("y = ",round(.$coefficients[1],2)," + ",round(.$coefficients[2],2),"*x")
  plot(y=df[,1],x=df[,2],main=eqn,ylab=colnames(df)[1],xlab=colnames(df)[2])
  abline(.)
}
plotSLR()
```

```{r}
# Main Program----------------------------------------

# set global parameters
alpha <- 0.01 #significance level - 95% confidence
p <- 1 #p value of statistical test
b0 <- 0 # b0 is the y-intercept parameter
b1 <- 1 #b1 is the slope parameter
E <- 0.5 # sample error or variance
n = 2 #number of samples
pVals <- rep(NULL,n)
#
                        

# Objective 1:
# determine the number of samples needed to have a significant result
while (p >= alpha){
  n <- n + 1
  for (i in seq(1,100)){
    myData <- simulateLinearXY(n=n,slope=b1,intercept=b0,error=E)
    myResults <- SLR_results(myData)
    if (i == 1){
      pVals[i]<- myResults['p_slope']
    }else {
    pVals[i]<- myResults['p_slope']
    }
  }
  p <- mean(pVals)
  #p <- mean(pVals<alpha)
}
print(c("number of samples"=n))
plotSLR(df=myData) 
#plotSLR(df=myData) 
# END PROGRAM-----------------------------------------
```

